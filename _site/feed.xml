<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-04-08T09:59:03+08:00</updated><id>/feed.xml</id><title type="html">Cookie.Joo Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">Jar包加固《三、Agent开发》</title><link href="/java/2022/04/08/jarx.html" rel="alternate" type="text/html" title="Jar包加固《三、Agent开发》" /><published>2022-04-08T00:00:00+08:00</published><updated>2022-04-08T00:00:00+08:00</updated><id>/java/2022/04/08/jarx</id><content type="html" xml:base="/java/2022/04/08/jarx.html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;Jar包的加密已经完毕了，现在开始做Jar包的解密开发，javaagent的开发工作量不多，只有是解密文件还原给应用使用。&lt;/p&gt;

&lt;h3 id=&quot;agent加载问题注意&quot;&gt;agent加载问题注意&lt;/h3&gt;

&lt;p&gt;开发加密Jar包的时候我的规划是文件操作的代码规划到core包里面，可以依赖一些方便的工具如：Apache common-land、io。guava等，而crypto包只用jdk提供的类提供加密的方法，RSE和AES都能满足了，文件操作也可以用io包解决，因为agent解密只要依赖crypto的包，不会依赖core包。&lt;/p&gt;

&lt;p&gt;agent最好不要依赖第三方包，除非你全部重写过第三方包和包名，否则容易出现传递依赖包冲突问题，比如你在agent包中用了guava的3.x版本，但是应用的包依赖的是guava的2.x版本，3.x版本删除过某个2.x版本的class，那么别人应用中用了这个类就会报错，因为传递依赖的时候agent是把2.x的代码打到他的class下面的，发现在agent有的情况下会优先用agent包内加载的代码，这点在写agent jar的时候是需要很谨慎的。&lt;/p&gt;

&lt;p&gt;大家有兴趣可以了解一下skywalking源码，它的agent虽然有用第三方包但是打包的pom都排除掉了，仅利用应用里面懒加载的jar依赖传递，就是避免用了它的agent启动不会因为全类名一致导致代码冲突，并且skywalking中你用了什么功能它才会被激活，一旦被激活，你的jar包肯定是有该依赖，这也是它的厉害之处。&lt;/p&gt;

&lt;p&gt;如果你的agent要用尽量都用&lt;scope&gt;provided&lt;/scope&gt;来声明依赖，agent都去使用应用加载的第三方包。&lt;strong&gt;但注意，如果应用里面都没依赖过这个包，那启动的时候一用到这个包的类就异常了。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;javaagent流程&quot;&gt;javaagent流程&lt;/h3&gt;

&lt;p&gt;我们加密的时候是把原始密码和Mac地址群分别放在Pass和Code文件里面，那么我们解密的时候是需要用到RSA私钥，那这个私钥存哪里也是个问题，目前暂定存放到环境变量中，如果觉得不稳妥，那就必须要在agent里面开发一个http去第三方配置中心取私钥了。&lt;/p&gt;

&lt;p&gt;http接口是&lt;可选&gt;逻辑。&lt;/可选&gt;&lt;/p&gt;

&lt;p&gt;得到私钥后到META-INF下面找Pass和Code解密得到原始密码和判断是否有Mac地址授权判断。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void premain(String args, Instrumentation inst) {
  。。。。。。
  //解密后重新定义Class：
  AgentTransformer tran = new AgentTransformer(password);
  inst.addTransformer(tran);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Transformer类中根据className到META-INF/xxxClasses文件夹下寻找对应的类，如果存在就进行解密返回新的byte[]，如果没有就返回原始byte[]。这里有个特殊的校验，即如何知道解密回来的文件是正常的class文件，如果你的文件被破坏了，可能就不是class文件，或者你的文件加密的时候是用txt格式内容，这里可能会转换错误的风险，我找了一些资料发现文件类型是有一个值可以区分的，就比如java文件有一个魔数，每个class文件前4个字节是CAFEBABE，Java语言的创始人设置的，爱喝咖啡的人有故事。&lt;/p&gt;

&lt;p&gt;所以我只要判断是否为正常的class文件则解密正确，也保证的还原了文件，毕竟加密有问题就会导致整个包都不可用风险系数极高。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,
                        ProtectionDomain domain, byte[] classBuffer) {
  if (className == null || domain == null || loader == null) {
    return classBuffer;
  }

  byte[] bytes = DECRYPT_UTILS.decode(projectPath, className, this.password);
  if (bytes == null) {
    return classBuffer;
  }
  if (isJavaMagicNumber(bytes)) {
    return bytes;
  } else {
    LOG.warn(&quot;解密到的文件格式非JAVA格式 :&quot; + className);
  }
  return classBuffer;
}

private static final byte CA = -54;
private static final byte FE = -2;
private static final byte BA = -70;
private static final byte BE = -66;

/**
 * 魔数占四个字节
 */
private boolean isJavaMagicNumber(byte[] bytes) {
  return bytes[0] == CA &amp;amp;&amp;amp; bytes[1] == FE &amp;amp;&amp;amp; bytes[2] == BA &amp;amp;&amp;amp; bytes[3] == BE;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;禁用attach&quot;&gt;禁用Attach&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;-XX:+DisableAttachMechanism&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;深度使用java的人基本都会用诊断功能如arthas工具，如何禁用其他工具attach到本进程呢？启动时加这个参数即可。&lt;/p&gt;

&lt;p&gt;但是加这个参数意味这你放弃使用jcmd、jstack、jmap和jinfo等命令，因为该命令不允许工具与JVM连接。&lt;/p&gt;

&lt;h3 id=&quot;启动效果&quot;&gt;启动效果&lt;/h3&gt;

&lt;p&gt;无论是懒加载或非懒加载，类被加载时都会先经过agent，agent作为应用的门卫角色，class被应用使用之前都会被优先校验或替换过。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407164650754.png&quot; alt=&quot;image-20220407164650754&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407164737747.png&quot; alt=&quot;image-20220407164737747&quot; /&gt;&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Java" /><category term="java" /><summary type="html">前言</summary></entry><entry><title type="html">Jar包加固《二、jar包处理流程》</title><link href="/java/2022/04/07/jarx.html" rel="alternate" type="text/html" title="Jar包加固《二、jar包处理流程》" /><published>2022-04-07T00:00:00+08:00</published><updated>2022-04-07T00:00:00+08:00</updated><id>/java/2022/04/07/jarx</id><content type="html" xml:base="/java/2022/04/07/jarx.html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;我们知道我们要实现的脉络后并生成了手脚架模块代码，接下来的事情就一路把功能代码填补上。&lt;/p&gt;

&lt;h3 id=&quot;整体流程图&quot;&gt;整体流程图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/1.png&quot; alt=&quot;流程&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jar包处理&quot;&gt;Jar包处理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;-filePath&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按我们定义的参数第一个是待加密的jar包路径，先判断文件是否存在，是否是jar类型的扩展名。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-publicPassword&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来是公钥，为什么是公钥，这里的加密设计是用RSA对一个原始密码加密，存放到一个文件内，如果有指定Mac地址，也用RSA加密放到另外一个文件内，这里多出两个文件，那就一起定义加密后的文件存放到哪里好了，从jar的目录结果来看，BOOT-INF是原始文件夹，还有一个是META-INF文件夹，我选择放META-INF文件夹里面用点号开头命名隐藏文件夹如：.xxxClasses。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;类uninx操作系统，以“.”开头的文件或文件夹，表示隐藏文件，ls，命令默认不显示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407142756538.png&quot; alt=&quot;image-20220407142756538&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个浅颜色表示隐藏文件，如果没有设置显示隐藏文件很难看出来加密后的文件存于此。而加密后的密码和Mac地址群都在里面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407144545022.png&quot; alt=&quot;image-20220407144545022&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-macCodes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Code和Pass文件都是RSA加密后的字符串，多个Mac地址就用逗号隔开即可。这里再次说明一下Mac地址校验问题，为什么要用逗号隔开这样设计而不是一个Mac地址打一个包。考虑到打制品包只能用一个最终制品，避免多制品不一致问题，打多个Mac地址包确实更安全，一个包传一个机器去，但是Jenkins打完后传到哪里这一步骤你在哪做都非常麻烦，要映射Mac和ip所在的机器连接关系，明显不现实且损失非常大，而且每打一个包要标明这个包对应的是那个ip用的，所以把Mac地址群放到一个Code文件里面是比较省事的方法。&lt;/p&gt;

&lt;p&gt;所以这里公钥参数的用法表达完了，也在代码里面约定了加密后的文件存储到META-INF/.xxxClasses文件夹下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-includeJars&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是否有二方包的代码需要加密，有就把二方包的jar解压，解压的临时目录就在当前的lib下，我这里的逻辑是大jar包建立一个临时目录_temp_来存放，二方包的目录就建立和二方包名称在加_temp_来存储，二方包哪些文件夹下的文件要加密就配合-packages参数使用，目录解构如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/WX20220406-183741.png&quot; alt=&quot;WX20220406-183741&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-packages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;待加密的文件代码我们按aop的切面方式进行配置，这种方式非常有利于我们对BOOT-INF下的源文件进行IO操作，因为包名就是文件夹的名称。我们只要解压得到文件夹，就可以把该文件夹下的所有文件变量去加密即可，最后在xxxClasses文件夹内用java包名方式存储加密后的文件即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407144401281.png&quot; alt=&quot;image-20220407144401281&quot; /&gt;&lt;/p&gt;

&lt;p&gt;class文件的加密是用原始密码进行AES方式加密的，所以密码有两道关，如果要解密class文件要知道原始密码和加密方式，得到原始密码要知道密码文件Pass所在的路径，并用私钥解密后得到原始密码再AES解密class就能读出正常class内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-excludeClasses&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是否有排除掉不需要加密的class类，这里可以按需指定。&lt;/p&gt;

&lt;h3 id=&quot;重写原始class&quot;&gt;重写原始class&lt;/h3&gt;

&lt;p&gt;对原始的class文件进行重写，把原本的方法体全部清空，只保留注释、注解、方法正确返回值。&lt;/p&gt;

&lt;p&gt;为什么要做这一步呢？能不能把class全部删掉，或者写一些乱七八糟的内容在里面？这里我们要知道：&lt;/p&gt;

&lt;p&gt;1：类加载是由双亲委派模式的，全部交由父类加载器从上Bootstrap -&amp;gt; Ext -&amp;gt; App -&amp;gt; 自己的类加载。&lt;/p&gt;

&lt;p&gt;2：我们有些API生成器是要从Jar包中直接解析得出的，或者运行启动时扫描BOOT-INF下的代码生成的。&lt;/p&gt;

&lt;p&gt;如果我们把BOOT-INF代码删了，或者变成一段不可运行的文本会导致怎么样？&lt;/p&gt;

&lt;p&gt;1：API文档无法支持，因为API是去加载代码和扫描注释生成的，这里可能代码都无法被加载就报错了，间接会影响到别人的一些文档工作。&lt;/p&gt;

&lt;p&gt;2：类加载问题，我们做个实验，把Application.class删掉会影响什么，启动时立马报错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/WX20220406-174737.png&quot; alt=&quot;WX20220406-174737&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为啥呢？因为SpringBoot的启动类必须要加载这个Application，类加载就会到这个路径下找class转成byte[]给jvm。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/WX20220406-175557@2x.png&quot; alt=&quot;WX20220406-175557@2x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3：如果我保留这个类不删，我把其他的删了总行吧？&lt;/p&gt;

&lt;p&gt;也不行，为啥？因为Spring的Aop就是要根据包路径扫描的，你把代码全部删了，那Spring就认为这个路径下没有代码，那么Controller的注解那些就没有加载过，前端Ajax就请求不到资源。&lt;/p&gt;

&lt;p&gt;4：那我能不能把代码都加密替换内容到里面？那我就不用把加密后的代码放META-INF了？省了一个空间。&lt;/p&gt;

&lt;p&gt;也不行，还是类加载问题，因为第一手类加载不是你加载的，你加密后的文件第一次被类加载是顶层的Loader，你只能等它加载过一遍，传递到agent的时你赶紧把加密后的文件还原回来且ClassLoader重加载后再传递给应用去用。如果你的第一手文件Byte都是错的，那启动的时候就直接报错了。&lt;/p&gt;

&lt;p&gt;所以，我们要想办法把原始class的方法体给清除掉，并且又能正常被加载，也就是还能作为一个正常的类来用。这也确保了如果别人拿到我们的包这个架子可以给你看，但是里面啥都没有，你看也看不出来是啥东西。看下图的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407153717845.png&quot; alt=&quot;image-20220407153717845&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实现这个目标我们用了javassist工具，它提供了很方便的工具方法重写原本的类，重编译后又能保证我这个类还能用。&lt;/p&gt;

&lt;h3 id=&quot;生成新jar包&quot;&gt;生成新jar包&lt;/h3&gt;

&lt;p&gt;最后就是把整个文件夹打包成新jar包&lt;/p&gt;

&lt;p&gt;1：先打包lib下的jar，记得删掉_temp_结尾的临时目录。&lt;/p&gt;

&lt;p&gt;2：把META-INF/maven文件夹给删掉，为啥？&lt;/p&gt;

&lt;p&gt;因为这个文件夹存储了pom信息，如果用了maven插件方式来加密的话，你的秘钥或密码都会暴露有安全风险，我们的依赖信息和私服地址都在里面，然而这个文件删除也不会影响启动，删！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407154425224.png&quot; alt=&quot;image-20220407154425224&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3：再整体把_temp_打成fatjar就是最后的完整可交付的jar包了，最后删除_temp_目录完毕。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-08-jarx/image-20220407154848009.png&quot; alt=&quot;image-20220407154848009&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;整个jar包的处理逻辑流程和技术疑虑基本解决了。&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Java" /><category term="java" /><summary type="html">前言</summary></entry><entry><title type="html">Jar包加固《一、预研与方向》</title><link href="/java/2022/04/06/jarx.html" rel="alternate" type="text/html" title="Jar包加固《一、预研与方向》" /><published>2022-04-06T00:00:00+08:00</published><updated>2022-04-06T00:00:00+08:00</updated><id>/java/2022/04/06/jarx</id><content type="html" xml:base="/java/2022/04/06/jarx.html">&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;我们在公司内网写代码、打包、部署都是在内网专有机器和专有网络上访问，所以基本不会考虑代码加密等问题。&lt;/p&gt;

&lt;p&gt;如果我们的代码要部署到公有云等外部机器上，或者与其他公司共建等共享机房内部署，那么就要考虑我们部署的代码要进行加密后上传到公有云机器上部署，从而避免别的公司会下载我们的部署包反编译查看我们的代码。&lt;/p&gt;

&lt;p&gt;如果我们的代码不进行加密等处理，那我们的业务极有可能&lt;/p&gt;

&lt;p&gt;1：被破解，内部数据隐私等泄露的风险。&lt;/p&gt;

&lt;p&gt;2：也很有可能被恶意通过字节码植入破坏性代码。&lt;/p&gt;

&lt;p&gt;3：被破解者绕过关键逻辑造成经济损失。&lt;/p&gt;

&lt;p&gt;正是要解决此类问题，我们不得不对代码进行加固处理。&lt;/p&gt;

&lt;h3 id=&quot;预研&quot;&gt;预研&lt;/h3&gt;

&lt;p&gt;我们正常的jar包里面的内容是什么样的呢？我们要怎么对现有的jar包进行加固呢？所以怎么下手是一个必须要面对的难题。我们以Spring-Boot的jar包为例，也是主流jar打包方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-06-jarx/WX20220406-175405@2x.png&quot; alt=&quot;WX20220406-175405@2x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正常Spring-Boot jar包解压后有3个文件夹&lt;/p&gt;

&lt;p&gt;BOOT-INT：存放该应用的第一方代码(即非maven引入的jar，你在这个项目可直接编辑的代码)&lt;/p&gt;

&lt;p&gt;META-INT：主要是配置文件，MAINFEST.MF是文件启动描述文件，Application.java全路径启动描述&lt;/p&gt;

&lt;p&gt;org：Spring-Boot的启动依赖类，Spring-Boot自己的类加载用的依赖类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-06-jarx/WX20220406-175557@2x.png&quot; alt=&quot;WX20220406-175557@2x&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;确认方向&quot;&gt;确认方向&lt;/h3&gt;

&lt;p&gt;从文件路径图中看，我们其实要处理的就一个文件夹「&lt;strong&gt;BOOT-INF&lt;/strong&gt;」，因为这里存放的是原始第一手class文件，和依赖的二方包、三方包jar文件，也就是要防止别人看的文件。&lt;/p&gt;

&lt;p&gt;那BOOT-INF文件夹分四类，一类是java文件，一类是静态前端文件，一类是配置文件都在classes文件夹内，lib是maven引入的jar包文件。&lt;/p&gt;

&lt;p&gt;我们观察一下classes的class必然要加密，静态前端文件基本都是vue用node编译后的文件，这种文件已经极其难看了就可以不用考虑加密处理了。配置文件呢我们一般是用第三方配置系统的，所以application.properties内存放的东西很少，也不会存放敏感信息的（如有敏感信息建议放第三方配置平台），所以也不用对这类文件做出来。lib下的第二方包我们得做加密，为啥呢？因为我们有很多api包、sdk包是自己写的模块代码，打成了jar包后给本应用模块依赖进来的，这些可能都是敏感文件肯定也不能给暴露了。其他的jar包就不用去加密了，因为这些第三方包基本都是开源的，或者不是业务相关的工具jar没必要加密。&lt;/p&gt;

&lt;p&gt;综合下来就classes的class文件和lib包的我们自己敏感二方包要加密。&lt;/p&gt;

&lt;p&gt;确定了要处理的文件后我们要确认一下行不行的通，我加密这些代码后会不会启动都启动不了了，我们启动jar包这些class怎么还原回来？&lt;/p&gt;

&lt;p&gt;我搜索了一下氪金产品，jar包加固都是提供一个加密软硬把包丢进去生成一个新的加密包，在提供一个javaagent包配合启动时解密，因为启动jar包时，javaagent是第一道关卡，从这个关卡中把class还原回来给class loader重定义后主程序就能用解密还原回来的class。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Instrumentation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addTransformer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//方法允许我们在类加载之前，重新定义Class，先看一下方法的定义：&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransformer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ClassFileTransformer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//ClassFileTransformer是一个接口，只有一个transform方法，它在主程序的main方法执行前，装载的每个类都要经过transform执行一次，可以将它称为转换器。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Javaagent这点特性很重要，它恰好解决了我们要类加载之前把class还原回来。用javaagent的话需要在启动时加启动参数配置，可以在启动sh包内加-D等参数判断，如果不是做过jar包加密的应用就不用加javaagent的参数，写在部署脚本里面这样也挺通用的。&lt;/p&gt;

&lt;p&gt;不过生成jar包不能用一个文件人工执行，我们要自己做这个实现，那我们得用到加解密的工具类如RSA、AES这类的非对称加解密文件，打包的工具我们要配合Jenkins那我们可以用脚本去运行Main方法进行jar加密后生成一个新的，或者在打包时用maven插件直接把打包后的包进行jar加密输出成另外一个包，但是要配合插件的参数判断是否要启用jar加密还是不用加密，这里可能会麻烦一点，那直接就用Main方法加密吧，写在Jenkins自定义脚本去执行。&lt;/p&gt;

&lt;p&gt;如果我们需要指定只能在某台机器上解密的话也得要支持，比如用mac地址，只能在这个mac地址的机器才能执行启动加解密，那也挺保险的，但是这个配置可能会导致一些问题不太灵活。比如扩容机器、机器坏了换机器那你得重新打包，紧急扩容的时候就很难受了。除非这些配置你在javaagent启动的时候先去远程调用配置中心的配置来做，但是这个配置存放在哪可能会有一些问题，比如你这个公有云是不能访问其他云网络的，你只能在你的公有云里面部署一下配置管理系统来做这个接口，这样确实有些启动依赖在里面的。&lt;/p&gt;

&lt;p&gt;是否要做这个第三方配置或许取决于小组讨论，主要就是还得考虑一下如果获取配置接口挂了的情况就无法启动了。&lt;/p&gt;

&lt;p&gt;我们规划一下这个jar包加固的手脚架&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;jarx-core:&lt;/strong&gt; Jarx的核心模块，对jar包解压、包下class加密功能，重新压缩成jar包；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;jarx-crypto:&lt;/strong&gt; Jarx的加密模块，用什么方式加密、解密；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;jarx-agent:&lt;/strong&gt; Jarx的agent启动依赖解密模块；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;jarx-fatjar:&lt;/strong&gt; Jarx的打包工具模块，从控制台中获取一系列参数调用core包加密jar（Jenkins自定义脚本就是要调用这个jar，需要提前打包好这个工具放到一个挂载盘中给Jenkins下载执行）；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;jarx-maven-plugin:&lt;/strong&gt; Jarx的maven打包插件；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fatjar和maven-plugin都是做加密打包用，就看用那种方便吧。&lt;/p&gt;

&lt;p&gt;我们要定义一些Main方法打包的参数，因为我想做的是classes包可以像aop已经切面去指定要加密的class，指定lib下哪些jar要加密，这些加的aop包也要说明，哪些类可以不加密。&lt;/p&gt;

&lt;h3 id=&quot;参数说明&quot;&gt;参数说明&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;是否必填&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-filePath&lt;/td&gt;
      &lt;td&gt;加密的jar/war完整路径&lt;/td&gt;
      &lt;td&gt;必填&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-packages&lt;/td&gt;
      &lt;td&gt;加密的包名，该包下所有class都会加密，多个用&quot;,&quot;分割&lt;/td&gt;
      &lt;td&gt;必填&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-publicPassword&lt;/td&gt;
      &lt;td&gt;公钥&lt;/td&gt;
      &lt;td&gt;必填&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-password&lt;/td&gt;
      &lt;td&gt;原始密码，不填则随机生成&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-excludeClasses&lt;/td&gt;
      &lt;td&gt;排除的全类名，多个用&quot;,&quot;分割&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-includeJars&lt;/td&gt;
      &lt;td&gt;jar包lib下要加密jar文件名，多个用&quot;,&quot;分割&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-macCodes&lt;/td&gt;
      &lt;td&gt;Mac地址，在绑定的机器生成，加密后只可在此机器上运行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;执行命令，配置用等于号进行配置，用空格隔开下一个配置&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; jarx-fatjar.jar &lt;span class=&quot;nt&quot;&gt;-filePath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx-app.jar &lt;span class=&quot;nt&quot;&gt;-includeJars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;a.jar,b.jar &lt;span class=&quot;nt&quot;&gt;-packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;com.qihoo.finance.应用a.modules,com.qihoo.finance.应用b.modules &lt;span class=&quot;nt&quot;&gt;-excludeClasses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;com.xxx.Application &lt;span class=&quot;nt&quot;&gt;-publicPassword&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx &lt;span class=&quot;nt&quot;&gt;-password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;123456 &lt;span class=&quot;nt&quot;&gt;-macCodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;90-9C-4A-CB-BC-FF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果: 生成 xxx-app-encrypted.jar，这个就是加密后的jar文件；加密后的文件不可直接执行，需要配合javaagent启动。&lt;/p&gt;

&lt;h3 id=&quot;整体架构图如下&quot;&gt;整体架构图如下&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-04-06-jarx/流程.png&quot; alt=&quot;流程&quot; /&gt;&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Java" /><category term="java" /><summary type="html">背景</summary></entry><entry><title type="html">Jar包加固产品对比</title><link href="/java/2022/04/05/jarx.html" rel="alternate" type="text/html" title="Jar包加固产品对比" /><published>2022-04-05T00:00:00+08:00</published><updated>2022-04-05T00:00:00+08:00</updated><id>/java/2022/04/05/jarx</id><content type="html" xml:base="/java/2022/04/05/jarx.html">&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;Jar包的加密在正常场景中运用较少，基本不会考虑此类加密处理，一般是在加密数据等领域居多，还有Android的SDK包等发布加密居多，一般简单的使用代码混淆proguard插件就能满足一些需求，但是该工具使用范围极其有限，简单模式的java模块还是可以满足的。&lt;/p&gt;

&lt;p&gt;市面的收费产品都是自研的整体加密方式，配合agent启动解密(该方向是java方向主流的Spring包应用)，在实现上确实有方便和独到之处。&lt;/p&gt;

&lt;h3 id=&quot;对比&quot;&gt;对比&lt;/h3&gt;

&lt;p&gt;下面的表格是我居于两种产品的对比列表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;–&lt;/th&gt;
      &lt;th&gt;代码混淆&lt;/th&gt;
      &lt;th&gt;Class文件加密&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;原理&lt;/td&gt;
      &lt;td&gt;将项目代码中包名、类名、方法名、参数名皆可混淆的工具打包插件，打包后的代码很难看&lt;/td&gt;
      &lt;td&gt;代码打包后将Jar中的class文件解压再加密后重新打包到Jar中，包名、类名、方法名等没有变化，仅对class内容加密&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;启动方式区别&lt;/td&gt;
      &lt;td&gt;java -jar即可启动，没有改变&lt;/td&gt;
      &lt;td&gt;必须利用javaagent在启动时将class内容解密还原再给ClassLoad加载，所以需依赖一个-javaagent&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;源码反编译区别&lt;/td&gt;
      &lt;td&gt;代码利用JD-GUI即可查看源码，或IDEA中也可查看jar包源码，但混淆后的源码极其难看难理解其含义&lt;/td&gt;
      &lt;td&gt;无法反编译源码，如需查看源码需知晓密码，并且解密方式繁琐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;代码输出方式&lt;/td&gt;
      &lt;td&gt;混淆后的代码输出为一个单独包含class的jar包，并非在fat  jar里面并成整体。这就带来了一个问题，就是先打混淆jar包，后通过再maven中引用jar包，并非能一步到位&lt;/td&gt;
      &lt;td&gt;Class加密后的代码和Fat Jar是一个整体，另外的一个agent  jar包可以提前预置在发布脚本和机器中。即时jar包不属于加密包，启动也不会有影响，利用配置参数判断是否需要自动加入-javaagent参数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;隐患&lt;/td&gt;
      &lt;td&gt;1、包名、类名的混淆会让Spring对特性的包扫描失效(如aop切面)；     2、方法名混淆会让jpa等第三方代理方法无法识别方法名；     3、类似ibatis的接口代理话可能出现以一些无法识别的问题。     4、对有些第三包用了高版本JDK编译不支持。&lt;/td&gt;
      &lt;td&gt;1、启动时对代码解密的agent需要稳定的解密测试；     2、对本身依赖多个agent的应用要优先把解密的本agent设置最高优先级。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;测试&lt;/td&gt;
      &lt;td&gt;混淆后的代码出现了一些切面代码无法识别的问题和代码的测试难度增加，需开发者自己Cover住&lt;/td&gt;
      &lt;td&gt;源码测试和正常情况一样，只需打包后部署一次完整测试即可。即：开发者不关心Jar加固的问题，只关心自己实现的功能代码即可&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;是否可标准化&lt;/td&gt;
      &lt;td&gt;混淆代码是不能标准化的，只能开发者自行做代码混淆的pom定义，不能在Jenkins等工具进行统一化管理&lt;/td&gt;
      &lt;td&gt;打包可以使用利用maven  package自定义插件进行打包，定义该插件打包即可，只需要在启动命令加配置判断是否需要标识该jar包是加密后的jar，就用解密jar方式添加-javaagent&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用难度&lt;/td&gt;
      &lt;td&gt;能正常打包没有异常就说明可用，很多异常不好看出问题，排除难度有些大&lt;/td&gt;
      &lt;td&gt;对agent加解密的代码需要很深的ClassLoad理解，个人担心的隐患在于agent中的解密和ClassLoad加载的问题不好判断；但对开发者是友好的，无需额外担心自身代码的问题。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;工具开发难度&lt;/td&gt;
      &lt;td&gt;1、无需开发。     2、在pom引入的maven plugin支持，应用开发者按帮助文档引用插件即可。&lt;/td&gt;
      &lt;td&gt;1、需开发。     2、需开发加解密的工具、agent包，并对解密agent的性能影响评估需更深入的测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;业界对比&lt;/td&gt;
      &lt;td&gt;因对Spring支持不友好，应用与SDK的打包居多，更多是工具包、加密信息的打包&lt;/td&gt;
      &lt;td&gt;很多付费的Jar加固方式都是用此方式，彻底屏蔽了反编译的路子，支持源码包加密，也可以对第三方包加密&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;最终制品支持&lt;/td&gt;
      &lt;td&gt;该方式是SDK单独加密，和最终输出的包是Jar或War无关，等于皆可支持&lt;/td&gt;
      &lt;td&gt;War和Jar都能运行-javaagent，所以皆可支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;加密方式&lt;/td&gt;
      &lt;td&gt;自有的一套对名称混淆的逻辑。&lt;/td&gt;
      &lt;td&gt;可自定义加密方式(AES/RES…)，可利用机器码进行加密，这样即可防止Jar被窃取后反编译破解的难度，仅限指定的机器码进行解码，但在容器部署的场景这个难支持。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最终还是选择自研的class文件加密方式，配合javaagent来运行。&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Java" /><category term="java" /><summary type="html">背景</summary></entry><entry><title type="html">什么是云原生？</title><link href="/cloud/2022/02/15/what-is-cloud-native.html" rel="alternate" type="text/html" title="什么是云原生？" /><published>2022-02-15T00:00:00+08:00</published><updated>2022-02-15T00:00:00+08:00</updated><id>/cloud/2022/02/15/what-is-cloud-native</id><content type="html" xml:base="/cloud/2022/02/15/what-is-cloud-native.html">&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;想必在IT的工作中&lt;strong&gt;云原生&lt;/strong&gt;(CloudNative)这个词会在工作或学习中出现无数次，其实我也很不理解什么是云原生，和我现在的码字工作沾到了哪些边？很多开源应用都是声称自己是云原生或向云原生靠拢的趋势。还有云计算、云服务器，这些是不是就是云原生？出于焦虑原因，我就不停的去翻找资料查Wiki，试图真正的理解这个概念，至少吹牛的时候自己还能搭上话。&lt;/p&gt;

&lt;p&gt;大多资料读完会感觉云绕雾罩，一知半解，让我更焦虑了；为了让我避免陷入自我怀疑的负面情绪，这些文章一概认为作者文字功底不行（如果别人看不懂我写的，那也可以认为我文字功底不行，但请不要怀疑自己）。&lt;/p&gt;

&lt;h3 id=&quot;历史&quot;&gt;历史&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-02-15-what-is-cloud-native/v2-f51c7a7bec2978533f5e6aaffe4d2faa_1440w.jpg&quot; alt=&quot;v2-f51c7a7bec2978533f5e6aaffe4d2faa_1440w&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看一下这个历史发展图，这个概念是2013年提出2015年推广，2013年Docker就出现了。&lt;/p&gt;

&lt;p&gt;我之前以为Docker就是云原生，后来发现也不对。&lt;/p&gt;

&lt;p&gt;我之前以为上云服务器的应用就是云原生，后来发现也不对。&lt;/p&gt;

&lt;p&gt;我之前意思得是云计算的应用才是云原生，后来发现也不对。&lt;/p&gt;

&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;2018年，Pivotal给出了云原生的最新定义：云原生是一种方法，用于构建和运行充分利用云计算模型优势的应用。云原生包含了一组应用的模式，用于帮助企业快速、持续、可靠、规模化地交付业务软件。云原生由微服务架构、DevOps和以容器为代表的敏捷基础架构组成。&lt;/p&gt;

&lt;p&gt;此后，CNCF给了另一版定义：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;看起来似懂非懂，反正先过一遍，思考一遍，至少想过这些词在现在的开发环境中都是用过，出现过的，如果还没用过什么如：微服务、DevOps、容器等（服务网格这个应该很多公司都没有或在筹划入局中【忽略】）那你该换工作了或别做IT了建议改行。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在看这个云原生问题之前你应该了解什么Docker（容器）什么是Kubernetes（容器编排）。云原生是一组思想集合和最佳实践，包括敏捷基础设施（agile infrastructure）、微服务（microservice）、DevOps、持续交付（continuous delivery）等。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这些概念、这些平台工具都是云原生的技术实现，我认为这些东西都是云原生的架构元素，就像“人”是一个概念，它有手脚、头脑等零部件（这些都是我个人去理解云原生的支撑依据）。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;我认为的云原生&quot;&gt;我认为的「云原生」&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;云原生的终极目的是为了提高开发效率，提升业务敏捷度、扩容性、可用性、资源利用率，降低成本。&lt;/strong&gt;谈云总会说到用哪家云平台，始终绕不过的问题，并非我这个应用部署在云服务器上就是云原生了，也不是用了哪个称为云某技术就是云原生。&lt;strong&gt;我们的应用应该是具备很强的灵活性，可以部署在任何云上，能与各种云技术对接，任何云都可以成为你的载体。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;云原生的关键是如何构建应用，而不是部署在哪里。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于我了解整个云原生的产品：Docker、K8S、微服务、DevOps等产品的概念与工作职责后，我能大概知道云原生是个什么概念了，是的，它只是一个概念。我们使用这些产品、这些平台、这些管理工具将我们的需求用代码描述，最终变成一个可执行文件，在服务器中跑起来，这就是云原生的一整套流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最终我认为：只要你的技术产品、你的技术工具、你的技术管理能帮助企业快速、持续、可靠、规模化地交付业务软件就属于云原生。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;我们为什么需要云原生&quot;&gt;我们为什么需要云原生？&lt;/h3&gt;

&lt;p&gt;它可以给企业省钱：容器的技术就是能充分利用机器的性能去部署更多的应用。&lt;/p&gt;

&lt;p&gt;它可以省时间：各种云技术都是开箱即用，都是尽力做到无状态化部署，使用这些技术在接入成本低、学习成本低。&lt;/p&gt;

&lt;p&gt;它可以省心：使用这些技术的目标可以让我们的运用运维成本低，如果运维成本很高，那这个技术肯定会被企业开发者抵触。&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;对于这个关键词我认为到这里就差不多了，真要论述起来，涉及的细枝末节太多，能大概知道个囫囵就够了，写多了连我自己也不想看。&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Cloud" /><category term="cloud" /><summary type="html">前言</summary></entry><entry><title type="html">Spring Boot自动装配流程</title><link href="/spring/2022/01/29/spring-auto-configuration.html" rel="alternate" type="text/html" title="Spring Boot自动装配流程" /><published>2022-01-29T00:00:00+08:00</published><updated>2022-01-29T00:00:00+08:00</updated><id>/spring/2022/01/29/spring-auto-configuration</id><content type="html" xml:base="/spring/2022/01/29/spring-auto-configuration.html">&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Spring Boot自动装配了解一下，所谓自动装配那自然是要关注@Configuration这个注解啦。&lt;/p&gt;

&lt;p&gt;追溯到源码发现有点像SPI技术，了解SPI技术的朋友看起来就没花什么力气了。SPI说白一点就是在某个规定的路径下存放的特定的配置文件（这就是技术规范），里面的内容就是需要应用启动的时候去加载类、初始化类的功能。如果各位朋友看SpringBoot源码到最后，其实也就是在特定的文件路径下特定的文件名，其内容是要初始化的全类路径，就是告诉Spring你要帮我搞定这些自定义类帮我变成你管理的Bean。&lt;/p&gt;

&lt;p&gt;这类的实现目的是什么呢？扩展性非常高了，Spring是一个Bean对象管理的高手，不单单是它自己的一些Bean，我们很多类自己实现的，那么你这种第三方的代码也可以给Spring管理，你就按照我Spring的规范去写代码，完了就写规定的配置文件，Spring启动时去整个jar包列表中全部找出这个特定路径文件帮你初始化Bean管理Bean。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（废话一下：我这人不喜欢用复杂的语言去描述一件事，很多人喜欢用复杂的东西去把一个普通的事情妖魔化，本来就是一加一等于二的事情，硬要套个二次元公式去跟别人讨论。其实你去国外的网站教程人家的解释都是讲说很简单的，很纯粹的思维。）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;源码&quot;&gt;源码&lt;/h3&gt;

&lt;p&gt;要了解Spring Boot自动装配，那就要从Spring Boot启动类注解开始，这也可以间接的了解了Spring Boot为啥不需要Tomcat容器去启动(有兴趣自己先去找资料了解一下)。&lt;/p&gt;

&lt;h4 id=&quot;springboot启动类&quot;&gt;SpringBoot启动类&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.cdg&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ComponentScan&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServerApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ServerApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spring Boot的启动类很简单，就是几个注解，Spring Boot为什么能简化Spring开发，就是因为它觉得单单Spring去开发一个项目pom依赖太多也太庞杂了，它开创了Spring Boot就是简化所有依赖进行整合，所以这个注解就是注解中的注解，也可以说注解功能整合或合并。&lt;/p&gt;

&lt;p&gt;ComponentScan也很重要啦，就是哪些类路径是我们这个项目Bean要交给Spring管理的，比如我这里就是com.cdg.*就配置一下(这里不啰嗦太多了)，一般不写就是ServerApplication下的所有包，比如这个类是在com.cdg下的，那么com.cdg.*所有的包类Spring都扫描去管理。&lt;/p&gt;

&lt;h4 id=&quot;springbootapplication注解&quot;&gt;SpringBootApplication注解&lt;/h4&gt;

&lt;p&gt;其中我们要关注的是SpringBootApplication注解。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RetentionPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Documented&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Inherited&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@SpringBootConfiguration&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@EnableAutoConfiguration&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ComponentScan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;excludeFilters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FilterType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CUSTOM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TypeExcludeFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FilterType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CUSTOM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AutoConfigurationExcludeFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringBootApplication&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;spring-boot启动类重要的三个注解&quot;&gt;Spring Boot启动类重要的三个注解&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;@SpringBootConfiguration 一看到这个就大概知道是个配置类注解&lt;/li&gt;
  &lt;li&gt;@EnableAutoConfiguration 这看英文单词就知道是个开关，就是是否要开始自动装配的功能注解&lt;strong&gt;（我们说自动装配嘛！这个注解意思很明确啦）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;@ComponentScan 上面有说&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;enableautoconfiguration注解&quot;&gt;EnableAutoConfiguration注解&lt;/h4&gt;

&lt;p&gt;该注解里面@Import(EnableAutoConfigurationImportSelector.class)是关键，是使用EnableAutoConfigurationImportSelector将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。同时借助于Spring框架的一个工具类：SpringFactoriesLoader&lt;strong&gt;（跟java提供的ServiceLoader类似）&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RetentionPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Documented&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Inherited&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@AutoConfigurationPackage&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Import&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AutoConfigurationImportSelector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EnableAutoConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-01-29-spring-auto-configuration/image-20220129154109084.png&quot; alt=&quot;image-20220129154109084&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个路径就是规范，约定好了这个路径下这个META/spring.factories文件内容就是Spring给用户扩展的配置文件，Spring就去里面帮你加载类且管理起来。我们找个其他jar包来看看基本就知道了。&lt;/p&gt;

&lt;h4 id=&quot;springfactories文件&quot;&gt;spring.factories文件&lt;/h4&gt;

&lt;p&gt;如Spring Boot提供了很多数据库集成，比如redis、mysql、mongodb等，我们看看这个spring-boot-autoconfigure包下的配置文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-01-29-spring-auto-configuration/image-20220129155243976.png&quot; alt=&quot;image-20220129155243976&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看看这个写法就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看看Mongodb连接的创建吧，网络很多是Redis，所以多看几个没坏处。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//上面的配置idea里面点进去&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;springframework&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;boot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;autoconfigure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MongoDataAutoConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
  
&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mongodb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;MongoTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Conditional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnyMongoClientAvailable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoProperties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Import&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoDataConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@AutoConfigureAfter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoAutoConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoDataAutoConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoProperties&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MongoDataAutoConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoProperties&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoDbFactorySupport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObjectProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;ObjectProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mongodb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongoClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoTemplate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mongoTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoDbFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;MongoConverter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;converter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MongoTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;converter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoConverter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MappingMongoConverter&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mappingMongoConverter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoDbFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;MongoMappingContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoCustomConversions&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conversions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GridFsTemplate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gridFsTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MongoDbFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;MongoTemplate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongoTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GridFsTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GridFsMongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongoDbFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;mongoTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConverter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MongoProperties这个类不陌生吧，就是在配置文件中找spring.data.mongodb前缀的mongodb连接地址、用户名密码。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@ConfigurationProperties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;spring.data.mongodb&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MongoProperties&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;总的来说就是创建Mongodb的连接类给你用如：MongoDbFactory、mongoTemplate、gridFsTemplate，&lt;strong&gt;需要额外说明的是它关注的是这个注解@Configuration&lt;/strong&gt;。我们要注意的是它有一个@ConditionalOnMissingBean注解，这个注解是如果你已经自己写了这种类，那么Spring就不会创建这个Bean了，会返回你创建的那个Bean，我们一般用Spring的咯。&lt;/p&gt;

&lt;p&gt;到了这里大家在写连接Redis、Mongo的例子的时候就会发现，你其实就引入Spring Boot redi/mongo的start依赖，然后配置文件配置一下连接地址等信息，你在Spring中就能使用这些连接模板类了吧，就是由于自动装配的功能帮你把Bean都给创建了，你只管用就行。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;我以前也是不知道META/spring.factories这个文件的，我也是先去了解java的SPI机制后，发现Spring中有这么个文件，我也不知道这个文件干嘛用的，自从接触Spring Boot自定义start依赖后才去了解这个自动装配。&lt;/p&gt;

&lt;p&gt;我是自己自定义配置了一些需要的框架工具方法才用到了这个技术，然后了解这个技术，其实你不用到也不会去了解，也没有机会去了解，没事就去论坛看看、公众号看看一些技术文章或面试题，有助于你去专研底层的原理，为什么呢？因为你也怕假如有一天去面试被问到同样的问题。&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Spring" /><category term="spring" /><summary type="html">前言</summary></entry><entry><title type="html">Spring Bean初始化流程</title><link href="/spring/2022/01/28/spring-bean-init.html" rel="alternate" type="text/html" title="Spring Bean初始化流程" /><published>2022-01-28T00:00:00+08:00</published><updated>2022-01-28T00:00:00+08:00</updated><id>/spring/2022/01/28/spring-bean-init</id><content type="html" xml:base="/spring/2022/01/28/spring-bean-init.html">&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;对于Bean的初始化流程，我觉得无需太专注去了解的，因为里面的东西太多了，对我们有啥帮助吗？没有，因为你只是应付将来可能面试时别人会问而已，拿到Offer了基本就扔掉了，如果是我的话我就直接说忘了或没怎么关注，我反而觉得里面的一些设计模式需要去探索一下的，远比应付面试要好千倍万倍。&lt;/p&gt;

&lt;p&gt;我这里也随便简单过一下，想到哪就聊到哪吧。我想鼓励你的是：没关注就是没关注，如果很重要我们就去补习，不是每一个人都有过目不忘的本领，我们时刻保持一颗学习的心态去面对工作和生活就好了。&lt;/p&gt;

&lt;h3 id=&quot;源码&quot;&gt;源码&lt;/h3&gt;

&lt;p&gt;下面我把关键的类方法贴出来大概说说它的流程是干嘛的，如果不感兴趣就瞎过一遍就行，重要的是里面的具体实现是值得我们去学习和深究的，我也是看了几遍源码去理解和找一些设计模式思想方法学习的，反正我也记不住，我就记住关键的一点什么时候创建Bean的。&lt;/p&gt;

&lt;p&gt;org.springframework.context.support.AbstractApplicationContext#refresh&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;refresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IllegalStateException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startupShutdownMonitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//容器刷新前的准备，设置上下文状态，获取属性，验证必要的属性等&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prepareRefresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//获取新的beanFactory，销毁原有beanFactory、为每个bean生成BeanDefinition&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ConfigurableListableBeanFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;obtainFreshBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//配置标准的beanFactory，设置ClassLoader，设置SpEL表达式解析器，添加忽略注入的接口，添加bean，添加bean后置处理器等&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prepareBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//模板方法，此时，所有的beanDefinition已经加载，但是还没有实例化。&lt;/span&gt;
					&lt;span class=&quot;c1&quot;&gt;//允许在子类中对beanFactory进行扩展处理。比如添加ware相关接口自动装配设置，添加后置处理器等，是子类扩展&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//实例化并调用所有注册的beanFactory后置处理器&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invokeBeanFactoryPostProcessors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//实例化和注册beanFactory中扩展了BeanPostProcessor的bean&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//如@Autowired、@Required、@PreDestroy、@PostConstruct、@Resource等注解&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerBeanPostProcessors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//初始化国际化工具类&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;initMessageSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//初始化事件广播器&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;initApplicationEventMulticaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//模板方法，在容器刷新的时候可以自定义逻辑，不同的Spring容器做不同的事情&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onRefresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//注册监听器，广播early application events&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerListeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//实例化所有剩余的（非懒加载）单例&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//**这步很重要了，上面都是做一些准备工作，这里就要开始创建Bean了，和如何解决循环依赖的问题都在这里面去触发调用，具体请看另外一篇文件，这里是触发创建Bean，所以要额外提示一下**&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;finishBeanFactoryInitialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//refresh做完之后需要做的其他事情。清除上下文资源缓存（如扫描中的ASM元数据），初始化上下文的生命周期处理器，并刷新（找出实现Lifecycle接口的bean并执行start()方法）&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;finishRefresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isWarnEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;destroyBeans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cancelRefresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;resetCommonCaches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>曹德高</name></author><category term="Spring" /><category term="spring" /><summary type="html">前言</summary></entry><entry><title type="html">Spring是如何解决循环依赖</title><link href="/spring/2022/01/28/spring-dependence.html" rel="alternate" type="text/html" title="Spring是如何解决循环依赖" /><published>2022-01-28T00:00:00+08:00</published><updated>2022-01-28T00:00:00+08:00</updated><id>/spring/2022/01/28/spring-dependence</id><content type="html" xml:base="/spring/2022/01/28/spring-dependence.html">&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Spring循环依赖，也就是说类A依赖了类B，类B又依赖类A，那么在项目启动的时候，由于系统不知道先加载A还是B，就会出现循环依赖的错误。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error creating bean with name &lt;span class=&quot;s1&quot;&gt;'AServiceImpl'&lt;/span&gt;: Bean with name &lt;span class=&quot;s1&quot;&gt;'AServiceImpl'&lt;/span&gt; has been injected into other beans &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;BServiceImpl,CServiceImpl,EServiceImpl]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最好的是重构代码抽取公用部分被大家一起依赖。&lt;/p&gt;

&lt;p&gt;或者用@lazy-init属性。在你注入bean时，在互相依赖的两个bean上加上@Lazy注解也可以。&lt;/p&gt;

&lt;p&gt;Spring是如何解决循环依赖问题的呢？下面我们从代码的角度的看看它是如何设计的。&lt;/p&gt;

&lt;h3 id=&quot;解析&quot;&gt;解析&lt;/h3&gt;

&lt;p&gt;Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，在AbstractBeanFactory中有注释：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Abstract base class for {@link org.springframework.beans.factory.BeanFactory}
 * implementations, providing the full capabilities of the
 * {@link org.springframework.beans.factory.config.ConfigurableBeanFactory} SPI.
 * Does &amp;lt;i&amp;gt;not&amp;lt;/i&amp;gt; assume a listable bean factory: can therefore also be used
 * as base class for bean factory implementations which obtain bean definitions
 * from some backend resource (where bean definition access is an expensive operation).
 
 * ## 这里给了链接让我们去看这个DefaultSingletonBeanRegistry类的实现。
 
 * &amp;lt;p&amp;gt;This class provides a singleton cache (through its base class
 * {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry},
 * singleton/prototype determination, {@link org.springframework.beans.factory.FactoryBean}
 * handling, aliases, bean definition merging for child bean definitions,
 * and bean destruction ({@link org.springframework.beans.factory.DisposableBean}
 * interface, custom destroy methods). Furthermore, it can manage a bean factory
 * hierarchy (delegating to the parent in case of an unknown bean), through implementing
 * the {@link org.springframework.beans.factory.HierarchicalBeanFactory} interface.
 *
 * &amp;lt;p&amp;gt;The main template methods to be implemented by subclasses are
 * {@link #getBeanDefinition} and {@link #createBean}, retrieving a bean definition
 * for a given bean name and creating a bean instance for a given bean definition,
 * respectively. Default implementations of those operations can be found in
 * {@link DefaultListableBeanFactory} and {@link AbstractAutowireCapableBeanFactory}.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Costin Leau
 * @author Chris Beams
 * @since 15 April 2001
 * @see #getBeanDefinition
 * @see #createBean
 * @see AbstractAutowireCapableBeanFactory#createBean
 * @see DefaultListableBeanFactory#getBeanDefinition
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractBeanFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FactoryBeanRegistrySupport&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConfigurableBeanFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实我也只能看懂其中一句话并猜测它的意思：是在未知bean的情况下委托给父级。然后通过看源码进行理解，所以就看DefaultSingletonBeanRegistry类是如何实现。&lt;/p&gt;

&lt;h4 id=&quot;三级缓存&quot;&gt;三级缓存&lt;/h4&gt;

&lt;p&gt;Spring是巧妙的用了三级缓存来存储创建Bean过程中的依赖问题，有点像是发号码牌的意味：卖菜小明的去饭店吃饭，饭店说先点菜点完后给小明一个号码牌坐着等一会叫号，饭店这时发现今天的菜这会11点半了都没准时送达，刚好眼下的小明就是这家饭店进货商，让这小明的赶紧回家拉一车菜来饭店。最后菜也到了，下锅炒了，小明也正常吃到饭了。&lt;/p&gt;

&lt;p&gt;我分成四类事件来理解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;小明去吃饭&lt;/li&gt;
  &lt;li&gt;点菜&lt;/li&gt;
  &lt;li&gt;号码牌&lt;/li&gt;
  &lt;li&gt;原材料是小明的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultSingletonBeanRegistry&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleAliasRegistry&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonBeanRegistry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObjects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;earlySingletonObjects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  
	&lt;span class=&quot;c1&quot;&gt;//三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;如果要看懂这个示例，可能需要再了解一下Bean的初始化流程是怎么样的，后续我看要不要写一个文章也填补一下。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;1、我们看一下我们获取Bean的方法它做了什么：AbstractAutowireCapableBeanFactory#&lt;strong&gt;doGetBean&lt;/strong&gt; 和 DefaultSingletonBeanRegistry#&lt;strong&gt;getSingleton&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;白话一下：对公司而言就只关心获取Bean(程序员)来干活(996)。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allowEarlyReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;//一级人间投胎了没有？&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSingletonCurrentlyInCreation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//没有就去二级地狱生死簿找有没有？&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;earlySingletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allowEarlyReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
					&lt;span class=&quot;nc&quot;&gt;ObjectFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonFactories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//没有就到三级混沌看有没有精元在重聚&lt;/span&gt;
					&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//有就收集三级混沌精元全部上升到二级地狱登记到生死簿中记录原神，清理三级混沌世界存在记录。&lt;/span&gt;
						&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
						&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;earlySingletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
						&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonFactories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
					&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、那Bean的创建它做了些什么呢？AbstractAutowireCapableBeanFactory#&lt;strong&gt;doCreateBean&lt;/strong&gt; 和 DefaultSingletonBeanRegistry#&lt;strong&gt;addSingletonFactory&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doCreateBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RootBeanDefinition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanCreationException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//是否是单例模式(请各位思考一下为啥是单例模式才能用这种3级缓存)，且允许未创建就暴露Bean&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;earlySingletonExposure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mbd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowCircularReferences&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;isSingletonCurrentlyInCreation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;earlySingletonExposure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isTraceEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Eagerly caching bean '&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
						&lt;span class=&quot;s&quot;&gt;&quot;' to allow for resolving potential circular references&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//这时候加的是什么 -&amp;gt; 是二级生死簿的引用，就是记个名知道有这么东西&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;addSingletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getEarlyBeanReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//初始化Bean&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exposedObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;populateBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instanceWrapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;exposedObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initializeBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exposedObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mbd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;--------------------------------------------------------------------------------------------&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addSingletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Singleton factory must not be null&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//一级人间投胎完成没有？第一次加载肯定没有&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//没有放入三级混沌做种子预备队&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonFactories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//清理干净二级地狱生死簿&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;earlySingletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//告知造物主有这么个东西要打算投生程序员并996一生&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registeredSingletons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、Bean初始化缓存升级到一级过程。DefaultSingletonBeanRegistry#&lt;strong&gt;addSingleton&lt;/strong&gt;，这里可以理解为给人间种下因果，无论如何都是要投胎的，所以不管是人是妖是灵都被虚拟化了一个位置在人间，等待真正实化的那一刻（变成^(*￣(oo)￣)^）。三个环节一环套一环。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;c1&quot;&gt;//当上面的doCreateBean做完后才会到这里把Bean上升到可用状态&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//升级到人间值得（投胎了）&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//混沌和生死簿全部清理干净&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonFactories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;earlySingletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registeredSingletons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;总的过程是先看投胎在人间了没有，没有就通知造物主在三级混沌世界修炼一下，发现三级混沌在苦逼修炼就大发慈悲上升到二级生死簿记载，一切罪孽都消除后就上升一级人间投胎，整个过程需要结合代码来不停的去验证才知道其中奥妙。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们搞个例子加图来过一遍吧，加深印象。&lt;/p&gt;

&lt;p&gt;假设有A、B、C 三个类依赖，A类有一个属性依赖B，B类有个属性依赖C，C类有个属性依赖A，这个就是循环依赖的示例。&lt;/p&gt;

&lt;p&gt;=&amp;gt; 1. A 创建 -&amp;gt; A 构造完成，开始注入属性，发现依赖 B，启动 B 的实例化&lt;/p&gt;

&lt;p&gt;=&amp;gt; 2. B 创建 -&amp;gt; B 构造完成，开始注入属性，发现依赖 C，启动 C 的实例化&lt;/p&gt;

&lt;p&gt;=&amp;gt; 3. C 创建 -&amp;gt; C 构造完成，开始注入属性，发现依赖 A&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-01-28-spring-dependence/image-20220128175616891.png&quot; alt=&quot;image-20220128175616891&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为什么构造器注入无法解决循环依赖？从中看出来，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入一级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。&lt;/li&gt;
  &lt;li&gt;上面提到多实例Bean为什么无法支持循环依赖(@Scope = prototype)？多实例Bean是每次创建都会调用doGetBean方法，根本没有使用一二三级缓存，肯定不能解决循环依赖。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>曹德高</name></author><category term="Spring" /><category term="spring" /><summary type="html">前言</summary></entry><entry><title type="html">Java线程池工作流程</title><link href="/java/2022/01/26/java-thread.html" rel="alternate" type="text/html" title="Java线程池工作流程" /><published>2022-01-26T00:00:00+08:00</published><updated>2022-01-26T00:00:00+08:00</updated><id>/java/2022/01/26/java-thread</id><content type="html" xml:base="/java/2022/01/26/java-thread.html">&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;面试的时候Java线程池的概念肯定是要被拷问到的一个知识点，一般说线程池的几个核心参数的作用，什么情况下会使用到最大线程数？线程是通过哪个类创建出来的？拒绝策略有哪些？基本上会答一通就差不多了。&lt;/p&gt;

&lt;p&gt;如当线程数据&amp;gt;=核心线程数 且 任务队列满时就会新建线程数到最大线程数据的范围；&lt;/p&gt;

&lt;p&gt;如线程是由实现ThreadFactory接口的DefaultThreadFactory去创建线程的，源码中就是new Thread()；&lt;/p&gt;

&lt;p&gt;当任务队列满时新的任务如何处理就看拒绝策略，默认的AbortPolicy就是抛异常。&lt;/p&gt;

&lt;p&gt;我们通过一个实际例子来看一下线程池在一批队列中他的执行时间的变化，得出的一些数据让我们更直观的感受一下这种参数设置的原理。&lt;/p&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.ArrayBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.atomic.AtomicInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @author cookie.joo
 * @date 2022-01-26
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutorTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;51&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * @param taskCount 任务数
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//核心线程数&lt;/span&gt;
                &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//最大线程数&lt;/span&gt;
                &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非核心回收超时时间&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//超时时间单位&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//任务队列&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;总任务数：&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//模拟任务提交&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//模拟执行耗时&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//默认拒绝策略抛异常&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;任务&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;被抛弃&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;taskCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCompletedTaskCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;任务总耗时：&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022-01-26-java-thread/image-20220126170100965.png&quot; alt=&quot;image-20220126170100965&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;解析&quot;&gt;解析&lt;/h3&gt;

&lt;p&gt;我们画个表格来对比一下，核心线程数是10，每一个执行耗时500ms，因为main线程启动是要时间的，再加上线程是异常执行的，所以多出来85毫秒或一些啰嗦时间这个可以理解为线程预热。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;5个任务或10个任务大概理论500毫秒左右执行完是能理解的；&lt;/li&gt;
  &lt;li&gt;从11个任务到30个开始就会多出500~1500毫秒来，是因为任务数没有达到满队列，最大线程数据没有被激活，所以30 \ 10 * 500 = 1500ms；&lt;/li&gt;
  &lt;li&gt;当任务数到40个的时候为什么会是两秒呢？这里很多人已经想到了，队列不是30吗？这里40已经满了呀。其实有十个在工作队列已经被取出来执行任务了，所以队列还是能存放30个任务，所以执行玩当前一组10个任务还有30个任务继续分成3组执行，就是4组需要2000ms。&lt;/li&gt;
  &lt;li&gt;重点来了。依照第三步所说，这里余下的是31个线程，这回应该要新建线程到20个了吧，如果是20个线程那么10一组另外31个会变成20一组+11一组就是耗时1500ms，然而现实就非我所愿还是2000ms，这是为什么呢？&lt;/li&gt;
  &lt;li&gt;45个任务的时候确实是用了20个最大线程数，50个也是，51个由于拒绝策略实际就执行50个任务，这里耗时1500ms也无悬念。45任务（10一组+&lt;strong&gt;20一组+15个一组&lt;/strong&gt;）、50任务（10一组+&lt;strong&gt;20一组+20个一组&lt;/strong&gt;）就是三组任务耗时1500ms。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;这里有个公式：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;公式①&lt;/td&gt;
      &lt;td&gt;任务数 &amp;lt;= 核心线程数时 &amp;lt;= 核心线程数 + 队列容量&lt;/td&gt;
      &lt;td&gt;线程池中工作线程数 = 任务数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;公式②&lt;/td&gt;
      &lt;td&gt;核心线程数 + 队列容量 &amp;lt; 任务数 &amp;lt;= 最大线程数 + 队列容量时&lt;/td&gt;
      &lt;td&gt;工作线程数 = 任务数 - 队列容量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;下列表格换算上面的公式：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;核心/最大线程数-队列容量&lt;/th&gt;
      &lt;th&gt;总任务数&lt;/th&gt;
      &lt;th&gt;总耗时(ms)&lt;/th&gt;
      &lt;th&gt;公式数据&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;585&lt;/td&gt;
      &lt;td&gt;① 执行批次为5 =》1 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;504&lt;/td&gt;
      &lt;td&gt;① 执行批次为10 =》1 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;1003&lt;/td&gt;
      &lt;td&gt;① 执行批次为10 + 1 =》2 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;1008&lt;/td&gt;
      &lt;td&gt;① 。。。20 =》2 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;1506&lt;/td&gt;
      &lt;td&gt;① 。。。30 =》3 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;40&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;① 执行批次为10 + 10 + 10 + 10 =》4 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;② 41-30=11，执行批次为11+11+11+8 =》4 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;1514&lt;/td&gt;
      &lt;td&gt;② 45-30=15，执行批次为15+15+15 =》3 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;1512&lt;/td&gt;
      &lt;td&gt;② 50-30=11，执行批次为20+20+10 =》3 * 500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 / 20 - 30&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;1517&lt;/td&gt;
      &lt;td&gt;拒绝了一个任务等同上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;遗留一个问题，如果是44个任务，最终的结果是耗时多少秒呢？各位去算一下吧。&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Java" /><category term="java" /><summary type="html">前言</summary></entry><entry><title type="html">JVM固定堆大小原理概解</title><link href="/jvm/2022/01/12/java-fixed-heap-size.html" rel="alternate" type="text/html" title="JVM固定堆大小原理概解" /><published>2022-01-12T00:00:00+08:00</published><updated>2022-01-12T00:00:00+08:00</updated><id>/jvm/2022/01/12/java-fixed-heap-size</id><content type="html" xml:base="/jvm/2022/01/12/java-fixed-heap-size.html">&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;可能很多人都知道Java程序上生产后，运维人员都会设定好JVM的堆大小，而且还是把最大最小设置成一样的值。那究竟是为什么呢？&lt;/p&gt;

&lt;p&gt;你是否有这个疑问？设置堆大小为何要设置成两个相同的固定值，一般不是小的设置小点，大的是一个上限值，我们一般的人认知不也是说随用随取吗，你设置为大小都一样会不会一开始就把空间全占了，让自己独享经济呗。&lt;/p&gt;

&lt;p&gt;我也有这个疑问，昨天我的同事让我给某个应用这么配，我也没想明白，然后我就找了好多资料，总结后跟你分享一下。&lt;/p&gt;

&lt;h3 id=&quot;初始化内存做了什么&quot;&gt;&lt;strong&gt;初始化内存做了什么&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;一般而言，Java程序如果你不显示设定该值得话，会自动进行初始化设定。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　　-Xmx &lt;span class=&quot;c&quot;&gt;#的默认值为你当前机器最大内存的 1/4		如本机有4G内存，这里1G&lt;/span&gt;
　　-Xms &lt;span class=&quot;c&quot;&gt;#的默认值为你当前机器最大内存的 1/64		这里就是64M&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然这样配置的意义是希望JVM可以根据当前运行的环境，动态伸缩堆内存大小。之所以生产上设置成固定大小，网上也是说法有很多，很多时候都是使用“防止内存抖动”这样的模糊词语给出解释。但是我相信各位也很懵很难去理解，不知道这个词具体表达什么含义。&lt;/p&gt;

&lt;p&gt;最大堆或最小堆，从字面上理解就是JVM在运行Java程序时，为其分配堆内存空间的上限和下限值。我们把最大和最小堆设置成相同值那意思就是分配了固定大小的内存呗。这样不就省去了动态调整内存（申请和释放）以及频繁的用户态和内核态的切换带来的开销吗？&lt;/p&gt;

&lt;p&gt;常理推论肯定是这样的。然而当我们尝试去做个模拟实验，事实却并非如此。比如，随便写个Java程序，使用如下命令启动之。并设置好固定大小堆为1G。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -Xmx1024m -Xms1024m -jar demo.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们通过查看进程的内存占用时，发现程序并没有占用1G的空间，而是很小的占用。这个实验结果和我们预期的完全不一致，&lt;strong&gt;并非独占、独享空间&lt;/strong&gt;。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java-fixed-heap-size/1-1956987.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;究竟是什么原因呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;问题其实出在我们对内存模型的理解上有问题。很多人可能都是像上面图中那样理解程序分配内存的。实际上是不对的，且也更复杂。首先我们要理解一个重要概念，那就是“进程的虚拟地址空间”，我们应用程序通过（malloc）这个系统函数申请内存，实际上就是申请了一个虚拟的内存，并不是真正的物理内存。&lt;strong&gt;大家要注意，这个虚拟的内存就是指“进程的虚拟地址空间”，而不是我们通常理解的Windows下的虚拟内存或Linux下的swap(分区交换)&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注：
   malloc 函数是C语言库函数，void *malloc(size_t size) 分配所需的内存空间，并返回一个指向它的指针。
   free 函数释放由其分配的内存。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;内存操作真相&quot;&gt;&lt;strong&gt;内存操作真相&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;应用程序申请的虚拟内存（虚拟地址空间），也就是通过malloc函数调用，本质就是在进程的虚拟地址空间里分配了一块&lt;strong&gt;地址范围&lt;/strong&gt;而已。32位系统理论上最大4G，每个进程都有自己的虚拟地址空间，都能申请到最大4G内存。但是申请了的内存，如果没有实际使用（写入数据），&lt;strong&gt;则操作系统不会给这块虚拟空间分配实际的物理内存&lt;/strong&gt;。其实原因很简单，物理内存一直属于紧缺资源，所以现代操作系统都设计为由内核程序统一管理，&lt;strong&gt;应用程序无权直接干涉&lt;/strong&gt;。不是说你申请多少就真的给你多少，而是你实际使用多少才会给你多少。&lt;/p&gt;

&lt;p&gt;你发现启动后程序内存占用很小就是这个原因。尽管JVM已经在你启动时向系统申请了1G的固定堆大小空间。程序刚启动时并没有实际的操作业务，所以你实际上只用到了很小的物理内存空间。但是如果随着系统的运行业务量越来越大，实际占用物理内存就会越来越多，直到达到申请的上限值1G。运行期间，你的程序同时也会通过GC释放一些对象，并在适当的时机归还一些物理内存给操作系统。所以占用的物理内存大小，也会动态有所调整。这样操作系统就可以给其他程序使用，提高了内存利用效率。这样的设计也没什么不好的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java-fixed-heap-size/2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，操作系统对内存管理是以页为基本单位的，一个页代表了一个固定大小的地址范围。应用程序给某个变量比如String赋值时，此时该变量对应的进程虚拟地址空间所在的页在物理内存上找不到对应的页映射时，就会触发了一个缺页中断异常，操作系统就会重新将虚拟地址的页映射到物理内存中的页，此时才是真正实现了内存分配，会占用实际的物理内存空间。假如Java程序的GC把这个String变量收回了，也就是不需要占用内存空间了，用户进程的堆管理器会适当的归还一些物理内存给操作系统，以便下次可以给其他任何程序使用。&lt;strong&gt;需要注意的是应用程序调用的malloc和free两个函数，都是针对应用进程的虚拟地址空间而言的，并不是实际操作物理内存。只有操作系统才拥有对实际物理内存的管理权限&lt;/strong&gt;。操作系统可以使用有效的各种算法，来独立高效的管理物理内存。&lt;/p&gt;

&lt;p&gt;我们发现在实际的Java程序，配置成固定堆大小后，内存占用一旦上去了就下不来了。即使当前程序处于比较空闲的状态下。这又是为什么呢？难道Java的GC没有回收内存？&lt;/p&gt;

&lt;p&gt;其实并不是GC没有回收内存，上面有提到GC回收内存并不是指物理内存，而是指当前进程的虚拟内存（虚拟地址空间）。一般而言，回收的虚拟内存并不会立即归还给操作系统，从而操作系统也就无法回收它了。至于何时归还物理内存，这取决于一个叫glibc的堆管理器。它根据一定的策略和算法适当的释放真实的物理内存。否则即便Java程序GC了对象，该对象占用的物理内存也不会立即释放出来。由于这里我们是设置了固定大小的堆空间，实际上GC回收的虚拟内存，也不会被释放归还给操作系统。故Java进程内存占用一旦增长，内存占用几乎都不会再下降了，这样也是出于对象再分配的效率考虑的。&lt;strong&gt;这样显然可以避免操作系统反复把进程的虚拟地址页复映射物理内存页（缺页中断异常）操作，导致频繁的用户态和内核态切换造成的性能问题&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;现在我们大概知道了为什么要设置JVM堆内存一样的原理了，总结起来有两点金句：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1：应用进程的内存都是操作虚拟地址空间，并不是实际操作物理内存。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2：避免操作系统反复把进程的虚拟地址页复映射物理内存页（缺页中断异常）操作，导致频繁的用户态和内核态切换造成的性能耗损。&lt;/strong&gt;&lt;/p&gt;</content><author><name>曹德高</name></author><category term="Jvm" /><category term="jvm" /><summary type="html">前言</summary></entry></feed>