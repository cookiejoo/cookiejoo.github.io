I"<p><strong>什么是经典的三种I/O模式</strong></p>

<p>我们在学Netty的时候讲的最多的就是Reactor的三种模式，因为他的这个模式用的最广泛，涉及的I/O知识点很基础也很常用。</p>

<!-- more -->
<ul>
  <li>我们去吃饭的时候：</li>
</ul>

<p>1：家乐园排队打饭，排队在窗口，打好才走。</p>

<p>2：点单，拿一个号码牌等待被叫，好了自己去端走。</p>

<p>3：辣可可包厢模式，点单后菜直接端上桌。</p>

<ul>
  <li>类比：</li>
</ul>

<p>饭店-&gt;服务器</p>

<p>饭菜-&gt;数据</p>

<p>饭菜好了-&gt;数据就绪</p>

<p>端菜、送菜-&gt;读取数据</p>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>特点</th>
      <th>JDK版本</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>排队打饭模式</td>
      <td>BIO（阻塞）</td>
      <td>JDK1.4之前</td>
    </tr>
    <tr>
      <td>点单被叫模式</td>
      <td>NIO（非阻塞）</td>
      <td>JDK1.4</td>
    </tr>
    <tr>
      <td>包厢消费模式</td>
      <td>AIO（异步）</td>
      <td>JDK1.7</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>阻塞与非阻塞区别：</p>

    <p>菜没好，要不要死等 -&gt; 数据就绪之前要不要等待。</p>

    <p>阻塞：没有数据传过来时，读会阻塞直到有数据；缓冲区满时，写操作也会阻塞。非阻塞：遇到这些情况都是直接返回。</p>
  </li>
  <li>
    <p>同步与异步区别：</p>

    <p>菜好了，谁端 -&gt; 数据就绪后，数据操作谁来完成？</p>

    <p>数据就绪后需要自己去读就是同步，数据就绪后直接读好再回调给程序是异步。</p>
  </li>
</ul>

<p><strong>总结</strong></p>

<p>所以BIO是阻塞同步方式；NIO是非阻塞同步方式；AIO是非阻塞异步方式。</p>

<p><strong>疑问</strong></p>

<p>Netty为什么仅仅支持NIO模式呢？为什么不用AIO模式呢？（Netty删掉了AIO的实现）</p>

<p>1：Windows实现AIO很成熟，但Win很少用来做服务器。</p>

<p>2：Linux常用来做服务器，但AIO实现不够成熟。</p>

<p>3：Linux下的AIO相比较NIO的性能提升不够明显。</p>

<p><strong>Reactor线程模型</strong></p>

<table>
  <thead>
    <tr>
      <th>生活场景</th>
      <th>饭店规模变化</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1：一个人包揽所有</td>
      <td>迎宾、点菜、做饭、上菜、送客等。</td>
    </tr>
    <tr>
      <td>2：多招几个伙计</td>
      <td>大家一起做上面的事情。</td>
    </tr>
    <tr>
      <td>3：进一步分工</td>
      <td>选一个或多个人专门做迎宾。</td>
    </tr>
  </tbody>
</table>

<p>Netty中的Reactor线程模型有三种，分别如下：</p>

<ol>
  <li>Reactor单线程模型；</li>
  <li>Reactor多线程模型；</li>
  <li>主从Reactor多线程模型；</li>
</ol>

<p><strong>–传统单线程模型–</strong></p>

<p>单线程模型简单，一个线程就一路走到底，优点是开发简单；缺点是如果某一个环节慢了，整个线程资源就拖垮了，甚至应用也会处理相当慢。</p>

<p>这个模型中最主要的就是每一步都是阻塞的，也就是BIO模型。有朋友会说改造成多线程不就解决了吗，多线程也只是用更多的线程做同样的事情而已，对应的每一步还是阻塞的。</p>

<p><img src="/images/netty-reactor/70.png" alt="在这里插入图片描述" /></p>

<p><strong>Reactor单线程模型</strong></p>

<p>下面的单线程Reactor模式因为服务端只有一个线程处理IO和业务逻辑，服务端性能肯定受到限制。虽然用了NIO的非阻塞方式，但一个线程如果挂了，这个应用基本也就挂了。因此就有了多线程版本。</p>

<p><img src="/images/netty-reactor/70-20210907141509987.png" alt="在这里插入图片描述" /></p>

<p><strong>Reactor多线程模型</strong></p>

<p>如下图所示，Reactor还是一个线程，负责监听IO事件以及分发，业务逻辑处理部分使用了一个线程池来进行处理（解码、计算、编码），这样就解决了服务端单线程处理请求而带来的性能瓶颈。就如生活场景中说的第二点，找多个人一起干同样的事。</p>

<p>但是这样还是有问题，这样会把性能的瓶颈转移到IO处理上。因为IO事件的监听和分发采用的还是单个线程，在并发量比较高的情况下，这个也是比较影响性能的。这是否还有继续优化的空间呢？</p>

<p><img src="/images/netty-reactor/70-20210907141512872.png" alt="在这里插入图片描述" /></p>

<p><strong>主从多线程模式</strong></p>

<p>我们知道Reactor主要是负责IO事件的监听和分发。单个Reactor单个线程这种模式在并发量比较高的情况下，会存在性能瓶颈。我们可以想象一下生活场景，开饭店最重要的是什么？我觉得是迎宾，找几个漂亮的小姑娘在门口，把客人先招揽进来，咱们做菜慢一点又有什么关系呢？流量都没进来，你的应用再强大饭菜做的再香也没有任何体现的价值。</p>

<p>那对于服务器而言最重要的是什么呢？是“接收连接”这个事情。主从模式更好的模式提高了性能利用率，他把acceptor单独注册到mainReactor里面去做接收连接事件。</p>

<p><img src="/images/netty-reactor/70-20210907142437684.png" alt="在这里插入图片描述" /></p>

<p><strong>最后</strong></p>

<p>我们所以的Netty服务端开发都是用了主从Reactor模式开编写，虽然说他不是最优的，比如我的业务就是只要几个连接就能完成事情，比如一个线程像一个VIP服务一样，也不会占用更多资源；或者这个项目就目前属于维护型项目，就不用什么改动了，就算改了也没有明显的效率提升反而增加了上线测试风险。但是考虑未来更多的可能性，都是建议使用第三种方式。</p>

<p>分析问题要从场景来分析，并非BIO就弱于NIO。</p>
:ET