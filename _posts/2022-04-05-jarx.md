---

title: "Jar包加固产品对比"
layout: post
author: 曹德高
tags: [java]
categories: Java
---

### 背景

Jar包的加密在正常场景中运用较少，基本不会考虑此类加密处理，一般是在加密数据等领域居多，还有Android的SDK包等发布加密居多，一般简单的使用代码混淆proguard插件就能满足一些需求，但是该工具使用范围极其有限，简单模式的java模块还是可以满足的。

市面的收费产品都是自研的整体加密方式，配合agent启动解密(该方向是java方向主流的Spring包应用)，在实现上确实有方便和独到之处。

### 对比

下面的表格是我居于两种产品的对比列表

| --             | 代码混淆                                                     | Class文件加密                                                |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原理           | 将项目代码中包名、类名、方法名、参数名皆可混淆的工具打包插件，打包后的代码很难看 | 代码打包后将Jar中的class文件解压再加密后重新打包到Jar中，包名、类名、方法名等没有变化，仅对class内容加密 |
| 启动方式区别   | java -jar即可启动，没有改变                                  | 必须利用javaagent在启动时将class内容解密还原再给ClassLoad加载，所以需依赖一个-javaagent |
| 源码反编译区别 | 代码利用JD-GUI即可查看源码，或IDEA中也可查看jar包源码，但混淆后的源码极其难看难理解其含义 | 无法反编译源码，如需查看源码需知晓密码，并且解密方式繁琐     |
| 代码输出方式   | 混淆后的代码输出为一个单独包含class的jar包，并非在fat  jar里面并成整体。这就带来了一个问题，就是先打混淆jar包，后通过再maven中引用jar包，并非能一步到位 | Class加密后的代码和Fat Jar是一个整体，另外的一个agent  jar包可以提前预置在发布脚本和机器中。即时jar包不属于加密包，启动也不会有影响，利用配置参数判断是否需要自动加入-javaagent参数 |
| 隐患           | 1、包名、类名的混淆会让Spring对特性的包扫描失效(如aop切面)；     2、方法名混淆会让jpa等第三方代理方法无法识别方法名；     3、类似ibatis的接口代理话可能出现以一些无法识别的问题。     4、对有些第三包用了高版本JDK编译不支持。 | 1、启动时对代码解密的agent需要稳定的解密测试；     2、对本身依赖多个agent的应用要优先把解密的本agent设置最高优先级。 |
| 测试           | 混淆后的代码出现了一些切面代码无法识别的问题和代码的测试难度增加，需开发者自己Cover住 | 源码测试和正常情况一样，只需打包后部署一次完整测试即可。即：开发者不关心Jar加固的问题，只关心自己实现的功能代码即可 |
| 是否可标准化   | 混淆代码是不能标准化的，只能开发者自行做代码混淆的pom定义，不能在Jenkins等工具进行统一化管理 | 打包可以使用利用maven  package自定义插件进行打包，定义该插件打包即可，只需要在启动命令加配置判断是否需要标识该jar包是加密后的jar，就用解密jar方式添加-javaagent |
| 使用难度       | 能正常打包没有异常就说明可用，很多异常不好看出问题，排除难度有些大 | 对agent加解密的代码需要很深的ClassLoad理解，个人担心的隐患在于agent中的解密和ClassLoad加载的问题不好判断；但对开发者是友好的，无需额外担心自身代码的问题。 |
| 工具开发难度   | 1、无需开发。     2、在pom引入的maven plugin支持，应用开发者按帮助文档引用插件即可。 | 1、需开发。     2、需开发加解密的工具、agent包，并对解密agent的性能影响评估需更深入的测试 |
| 业界对比       | 因对Spring支持不友好，应用与SDK的打包居多，更多是工具包、加密信息的打包 | 很多付费的Jar加固方式都是用此方式，彻底屏蔽了反编译的路子，支持源码包加密，也可以对第三方包加密 |
| 最终制品支持   | 该方式是SDK单独加密，和最终输出的包是Jar或War无关，等于皆可支持 | War和Jar都能运行-javaagent，所以皆可支持                     |
| 加密方式       | 自有的一套对名称混淆的逻辑。                                 | 可自定义加密方式(AES/RES...)，可利用机器码进行加密，这样即可防止Jar被窃取后反编译破解的难度，仅限指定的机器码进行解码，但在容器部署的场景这个难支持。 |

最终还是选择自研的class文件加密方式，配合javaagent来运行。
